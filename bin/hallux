#!/bin/env python
# Copyright: Hallux team, 2023

# MAIN COMMAND-LINE EXECUTABLE
# - Runs checks in the current folder (linting / unit-tests / docstrings / compilation errors)
# - Extracts every single message
# - Makes a prompt for every message
# - Sends prompt to GPT, receives answer,
# - Changes code right in the codebase or sends this change as Github Web GUI proposal


from __future__ import annotations

import copy
import subprocess
import os
import sys
import tempfile
from abc import ABC, abstractmethod
from typing import Final
import yaml
import re
from pathlib import Path
import openai
from numpy.core.defchararray import isnumeric
from openai.api_resources import ChatCompletion
from diff_target import DiffTarget, FilesystemTarget, GitCommitTarget, GithubProposalTraget
# from cpp import CppFeatureExecutor


def load_config() -> tuple[dict | None, Path | None]:
    curr_path = Path(os.getcwd())
    while not curr_path.joinpath(".hallux").exists() and curr_path.parent != curr_path:
        curr_path = curr_path.parent
    if not curr_path.joinpath(".hallux").exists():
        return None, None
    config_file = str(curr_path.joinpath(".hallux"))
    with open(config_file) as file_stream:
        yaml_dict = yaml.load(file_stream, Loader=yaml.CLoader)
    return yaml_dict, curr_path


class PromptExecutor:
    def __init__(self, model: str):
        self.model = model

#
#     @abstractmethod
#     def process(self):
#         pass
#
# class FeatureExecutor(ABC):
#     def __init__(self):
#         pass
#
#     @abstractmethod
#     def process(self):
#         pass
#
#
# class PythonRuffLinting(FeatureExecutor):
#     def __init__(self, params, diff_target: DiffTarget):
#         super().__init__()
#         self.diff_target = diff_target
#
#     def process(self):


class QueryBackend(ABC):

    @abstractmethod
    def query(self, request:str) -> str | None :
        pass


class OpenAiChatGPT(QueryBackend):
    def __init__(self, model: str, max_tokens: int):
        self.model = model
        self.max_tokens = max_tokens

    def query(self, request:str) -> list[str]:
        result = ChatCompletion.create(messages=[{"role": "user", "content": request}], model=self.model)
        answers = []
        if len(result["choices"]) > 0:
            print(result["choices"])
            for variant in result["choices"]:
                answers.append(variant["message"]["content"])
        return answers

class Hallux:
    def __init__(self, query_backend: QueryBackend, config: dict, base_path: Path, diff_target: DiffTarget):
        self.query_backend = query_backend
        self.config: Final[dict] = config
        self.base_path: Final[Path] = base_path
        self.diff_target: Final[DiffTarget] = diff_target
        self.debug: bool = True

    def process(self):
        if "python" in self.config.keys():
            self.python(self.config["python"])
        if "cpp" in self.config.keys():
            self.cpp(self.config["cpp"])
            # cpp = CppFeatureExecutor()
            # cpp.process()

    def python(self, config: dict):
        print("Process Python issues:")
        if "linting" in config.keys():
            self.python_linting(config["linting"])
        if "tests" in config.keys():
            self.python_tests(config["tests"])
        if "docstrings" in config:
            self.python_docstrings(config["docstrings"])

    def python_linting(self, params: str | None):
        if params is None or params == "ruff":
            self.python_linting_ruff(["ruff", "check", "."])
        else:
            print("We only support RUFF for python lint")
            exit(5)

    @staticmethod
    def read_lines(filename: str, line: int, raidus: int, add_comment:str|None = None) -> tuple[int, int, list[str], list[str]]:
        with open(filename, "rt") as file:
            filelines = file.read().split("\n")
        start_line = max(0, line - raidus)
        end_line = min(len(filelines) - 1, line + raidus)
        requested_lines = copy.deepcopy(filelines[start_line:end_line])
        requested_lines[line-start_line+1] += add_comment
        return start_line, end_line, requested_lines, filelines

    @staticmethod
    def prepare_lines(query_result: str, remove_comment:str|None = None) -> list[str]:
        resulting_lines = query_result.split("\n")
        for i in range(len(resulting_lines)):
            line : str = resulting_lines[i]
            if line.endswith(remove_comment):
                resulting_lines[i] = line[:-len(remove_comment)]
                break
        return resulting_lines

    def python_linting_ruff(self, command):
        print("Process python linting issues:")

        try:
            subprocess.check_output(command)
            print("No python linting issues found")
        except subprocess.CalledProcessError as e:
            ruff_output = e.output

            warnings: list[str] = str(ruff_output.decode("utf-8")).split("\n")
            for warn in warnings[:-2]:
                print(warn)
                filename = warn.split(" ")[0].split(":")[0]
                warn_line = int(warn.split(" ")[0].split(":")[1])
                added_comment: str = " # line " + str(warn_line)
                start_line, end_line, warnlines, filelines = self.read_lines(filename, warn_line, 4, added_comment)

                # with open(filename, "rt") as file:
                #     filelines = file.read().split("\n")

                request = "Fix python linting issue, write resulting code only:\n"
                request = request + warn + "\n"
                request = request + "Excerpt from the corresponding python file (not full):\n"

                for line in warnlines:
                    request = request + line + "\n"

                print("request")
                print(request)

                result : str

                if self.debug:
                    result = ["        try:\n" + \
                                     "            token1 = next(tokens1)\n" + \
                                     "            token2 = next(tokens2)\n" + \
                                     "        except:\n" + \
                                     "            break\n\n@pytest.mark.parametrize(\n"]

                else:
                    result = self.query_backend.query(request)

                    # result = ChatCompletion.create(messages=[{"role": "user", "content": request}], model=self.model)
                    # print("result")
                    # print(result)
                    #
                    # if len(result["choices"]) > 0:
                    #     print(result["choices"])
                    #     for variant in result["choices"]:
                    #         resulting_code = variant["message"]["content"]


                if len(result) > 0:
                    #resulting_code : str = result[0]
                    # resulting_lines = resulting_code.split("\n")
                    # for i in range(len(resulting_lines)):
                    #     line : str = resulting_lines[i]
                    #     if line.endswith(added_comment):
                    #         resulting_lines[i] = line[:-len(added_comment)]
                    #         break
                    resulting_lines = self.prepare_lines(result[0], added_comment)

                    self.diff_target.apply_diff(filename, start_line, end_line, resulting_lines, warn)

                if self.debug:
                    break

    def python_tests(self, params: dict | str):
        pass

    def python_docstrings(self, params: dict | str):
        pass

    def cpp(self, config : dict) -> int:
        print("Process C++ issues:")
        makefile_dir: Path
        if "makefile_dir" in config.keys():
            makefile_dir = Path(config["makefile_dir"])
        elif self.base_path.joinpath("CMakeLists.txt").exists():
            makefile_dir = Path(self.prepare_makefile_dir())
        else:
            print("You enabled cpp in the .hallux config file, but not specified `makefile_dir` nor CMakeLists.txt was found")
            return 5

        if not makefile_dir.joinpath("Makefile"):
            print(f"{str(makefile_dir.joinpath('Makefile'))} does not exist")
            return 5

        if "compile" in config.keys():
           self.cpp_compile(config["compile"], makefile_dir)
        if "linking" in config.keys():
            self.cpp_linking(config["linking"])
        if "tests" in config.keys():
            self.cpp_tests(config["tests"])


    def prepare_makefile_dir(self) -> str | None:
        makefile_dir = tempfile.mkdtemp(dir='/tmp/hallux')
        os.chdir(makefile_dir)
        try:
            subprocess.check_output(["cmake", f"{str(self.base_path)}"])
            print("CMake initialized succesfully")
        except subprocess.CalledProcessError as e:
            cmake_output = e.output.decode("utf-8")
            print("CMake initialization failed:")
            print(cmake_output)
            exit(5)
            return None

        return makefile_dir


    def cpp_compile(self, params: dict | str, makefile_dir: Path):
        os.chdir(str(makefile_dir))
        make_output = subprocess.check_output(["make", "help"])
        targets: list[str] = str(make_output.decode("utf-8")).split("\n")
        target: str
        processed = 0
        for target in targets:
            if target.endswith(".o"):
                target = target.lstrip(".")
                target = target.lstrip(" ")
                self.compile_make_target(target)

    # def find_cpp_file(self, make_target: str) -> Path | None:
    #     make_target = make_target[:-2]
    #     target_list : list[str] = make_target.split("/")
    #     path = self.base_path
    #     while len(target_list) > 1:
    #         if path.joinpath(target_list[0]).exists():
    #             path = path.joinpath(target_list[0])
    #             target_list = target_list[1:]
    #
    #     if isinstance(target_list, list):
    #         target_name = target_list[0]
    #     else:
    #         target_name = target_list
    #
    #     repo_files: list[str] = os.listdir(str(path))
    #     for filename in repo_files:
    #         if filename.startswith(target_name):
    #             return path.joinpath(filename)
    #
    #     return None

    def parse_compilation_error(self, make_output : str) -> tuple[list[list[str]], list[list[str]]]:
        output_lines : list[str] = make_output.split("\n")
        errors : list[list[str]] = []
        warnings : list[list[str]] = []
        err_amount : int = 0
        warn_amount : int = 0
        error : list[str] | None = None
        warning : list[str] | None = None

        for line_num in range(len(output_lines)):
            err_line_list = output_lines[line_num].split(":")
            #if re.match("^/([a-zA-Z0-9/_]).cpp:([0-9]):([0-9]): error: ", output_lines[line_num]):
            if len(err_line_list) > 4 and err_line_list[3] == " error" and isnumeric(err_line_list[1]) and isnumeric(err_line_list[2]):
                if error is not None:
                    error = error[:-1]
                    errors.append(error)
                    error = None
                if warning is not None:
                    warning = warning[:-1]
                    warnings.append(warning)
                    warning = None

                err_amount += 1
                print(output_lines[line_num])
                error = [output_lines[line_num-1]] if line_num > 0 else []
                error.append(output_lines[line_num])
            elif len(err_line_list) > 4 and err_line_list[3] == " warning" and isnumeric(err_line_list[1]) and isnumeric(err_line_list[2]):
                if error is not None:
                    error = error[:-1]
                    errors.append(error)
                    error = None
                if warning is not None:
                    warning = warning[:-1]
                    warnings.append(warning)
                    warning = None
                warn_amount += 1
                print(output_lines[line_num])
                warning = [output_lines[line_num-1]] if line_num > 0 else []
                warning.append(output_lines[line_num])
            elif error is not None:
                error.append(output_lines[line_num])
            elif warning is not None:
                warning.append(output_lines[line_num])

        print(f"{err_amount} errors , {warn_amount} warnings found")
        return errors, warnings


    def compile_make_target(self, target) -> int:
        try:
            subprocess.check_output(["make", target], stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            make_output : str = e.output.decode("utf-8")
            print("Compilation errors found:")
            #print(make_output)
            # erroneous_file = self.find_cpp_file(target)
            # print(f"Corresponding file: {erroneous_file}")

            errors, warnings = self.parse_compilation_error(make_output)

            for error in errors:
                props = error[1].split(":")
                filename = props[0]
                err_line : int  = int(props[1])
                added_comment = f" // {err_line}"
                start_line, end_line, warnlines, filelines = self.read_lines(filename, err_line, 4, added_comment)
                print(error)

                request = "Fix gcc compilation issue, write resulting code only:\n"
                for line in error:
                    request = request + line + "\n"

                request = request + "Excerpt from the corresponding cpp file (not full):\n"

                for line in warnlines:
                    request = request + line + "\n"

                print("request")
                print(request)

                result = self.query_backend.query(request)
                print("result")
                print(result)


                if len(result) > 0:
                    resulting_lines = self.prepare_lines(result[0], added_comment)

                    self.diff_target.apply_diff(filename, start_line, end_line, resulting_lines, error[1])

                if self.debug:
                    break


        return 0


    def cpp_linking(self, params: dict | str):
        pass

    def cpp_tests(self, params: dict | str):
        pass


if __name__ == "__main__":
    print("Hallux v0.1 - Convenient Coding Assistant")
    if len(sys.argv) < 2 or sys.argv[1] not in ["fix", "propose", "commit"]:
        print("Usage: hallux fix | hallux commit  | hallux propose Github_PullRequest_ID")
        exit(0)

    config, path = load_config()
    if config is None:
        print("Error: config file not found")
        exit(1)

    if "backend" in config and "openai" in config["backend"]:
        backend = OpenAiChatGPT(model=config["backend"]["openai"]["model"], max_tokens=config["backend"]["openai"]["max_tokens"])
    else:
        print("Backend is not properly configured")
        exit(2)


    target: DiffTarget

    if sys.argv[1] == "fix":
        target = FilesystemTarget()
    elif sys.argv[1] == "commit":
        target = GitCommitTarget()
    else:
        target = GithubProposalTraget(sys.argv[2])

    #os.chdir(str(path))
    print(config)

    openai.api_key = os.getenv("OPENAI_API_KEY")

    hallux = Hallux(query_backend=backend, config=config, base_path=path, diff_target=target)

    hallux.process()

